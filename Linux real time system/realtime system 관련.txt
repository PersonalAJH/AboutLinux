리눅스 실시간 스케줄링 시스템
리눅스에서 실시간 스케줄링은 특정 작업에 더 높은 우선순위를 부여하고, 보다 예측 가능한 실행을 보장하는 데 사용됩니다. 실시간 시스템의 주요 목적은 반응 시간을 최소화하고, 작업 처리 순서를 엄격하게 관리하는 것입니다.

스케줄링 정책:

SCHED_FIFO: FIFO 실시간 정책입니다. 같은 우선순위를 가진 프로세스 간에는, 먼저 대기열에 들어온 프로세스가 먼저 실행됩니다.

동작 방식
정적 우선순위: 프로세스는 시작 시 할당받은 우선순위를 유지하며, 이 우선순위는 실행 도중에 변경되지 않습니다.
FIFO 큐: 같은 우선순위를 가진 프로세스들은 FIFO(선입선출) 방식의 큐에서 관리됩니다. 가장 먼저 큐에 들어온 프로세스가 CPU를 점유하게 됩니다. ( 마치 C++ 의 priority queue 와 같은 방식)
CPU 점유: 한 프로세스가 CPU를 점유하고 있으면, 같은 우선순위를 가진 다른 프로세스는 대기해야 합니다. 점유 중인 프로세스가 CPU를 자발적으로 양보하거나, 블록되어 실행이 중단될 때까지 CPU를 계속 사용합니다.
비선점형 스케줄링: 한번 CPU를 점유하면, 더 높은 우선순위의 프로세스가 실행 준비 상태가 되어도 중단되지 않습니다. 오직 더 높은 우선순위의 프로세스만이 현재 실행 중인 SCHED_FIFO 프로세스를 선점할 수 있습니다.
적용 대상: SCHED_FIFO는 시간에 민감한 실시간 작업에 주로 사용됩니다. 예를 들어, 실시간 데이터 처리, 고속 데이터 수집, 로봇 제어 등의 작업이 이에 해당합니다. 이 정책은 작업의 응답 시간을 최소화하고, 예측 가능한 실행을 보장해야 하는 경우에 적합합니다.
%주의사항%
SCHED_FIFO 프로세스는 CPU를 과도하게 점유할 수 있으므로, 시스템의 다른 중요한 작업들에 영향을 줄 수 있습니다. 따라서 신중하게 사용해야 합니다.
실시간 우선순위를 가진 프로세스는 일반적으로 높은 사용자 권한(예: root)을 필요로 합니다.
SCHED_FIFO 정책은 그 특성상 시스템 자원을 독점할 수 있으므로, 이를 사용할 때는 프로세스가 시스템의 전체 성능과 안정성에 미치는 영향을 고려해야 합니다. 실시간 시스템에서는 이러한 특성이 중요할 수 있지만, 일반적인 용도의 시스템에서는 주의해서 사용해야 합니다.





그 외의 스케쥴링 정책
1. SCHED_OTHER
개요: 이것은 가장 일반적인 비실시간 타임쉐어링 스케줄링 정책입니다.
동작 방식: 이 정책은 동적 우선순위 할당을 사용합니다. 프로세스의 우선순위는 시스템 부하, 실행 히스토리, 사용자 인터랙션 등에 따라 동적으로 조정됩니다.
적용 대상: 대부분의 일반 사용자 프로세스가 이 정책을 사용합니다. 시스템의 대화식 사용자 애플리케이션 및 배경 작업에 주로 사용됩니다.

2. SCHED_BATCH
개요: CPU 집약적인 배치 작업을 위한 정책입니다.
동작 방식: SCHED_OTHER와 유사하지만, 더 긴 타임 슬라이스와 더 적은 스케줄링 오버헤드를 제공하여 배치 작업의 효율을 높입니다. 이 정책은 사용자 상호작용이 적고, CPU 시간을 많이 소모하는 작업에 적합합니다.
적용 대상: 데이터 처리, 비디오 인코딩, 대규모 계산 작업 등의 배치 프로세스에 적합합니다.

3. SCHED_IDLE
개요: 매우 낮은 우선순위를 가진 프로세스를 위한 정책입니다.
동작 방식: 이 정책 하에서 실행되는 프로세스는 시스템이 거의 유휴 상태일 때만 CPU 자원을 사용합니다. 즉, 다른 모든 활동이 완료된 후에만 실행됩니다.
적용 대상: 유지 보수 작업, 백업 작업, 시스템 모니터링과 같이 긴급하지 않고 시스템 부하에 민감하지 않은 작업에 적합합니다.

4. SCHED_RR (Round Robin)
개요: 실시간 타임쉐어링 스케줄링 정책입니다.
동작 방식: SCHED_FIFO와 유사하지만, 각 프로세스에 고정된 타임 슬라이스(quantum)를 할당합니다. 타임 슬라이스가 끝나면, 동일한 우선순위를 가진 다음 프로세스에게 CPU가 할당됩니다.
적용 대상: 실시간 시스템에서 사용되며, 타임 크리티컬한 작업을 수행하는데 적합합니다.

5. SCHED_DEADLINE
개요: 각 프로세스에 실행 마감시간을 설정하는 최신 실시간 스케줄링 정책입니다.
동작 방식: 프로세스는 정해진 마감시간 내에 실행을 완료해야 하며, 마감시간이 가까운 프로세스에게 우선순위가 주어집니다. 이 정책은 프로세스의 실행 시간, 마감 시간, 주기 등을 고려하여 스케줄링합니다.
적용 대상: 정확한 타이밍이 필수적인 실시간 응용 프로그램에 적합합니다. 예를 들어, 멀티미디어 처리, 로봇 제어 등이 있습니다.




# CPU 사용의 양보 (블록 혹은 자발적 양보)
1. 자발적인 CPU 양보:
프로세스가 실행 중 sleep() 함수나 그와 유사한 시스템 호출을 사용하여 일시적으로 실행을 중단하고 CPU를 양보하는 경우입니다.
예를 들어, usleep() 또는 nanosleep() 함수를 사용하여 프로세스를 지정된 시간 동안 대기 상태로 만들 수 있습니다.

2. I/O 작업 또는 시스템 호출:
프로세스가 파일 읽기/쓰기, 네트워크 통신 등의 I/O 작업을 요청하는 경우, 해당 I/O 작업이 완료될 때까지 프로세스가 블록됩니다.
시스템 호출을 통해 리소스 요청이나 다른 커널 서비스를 이용하는 경우도 프로세스가 대기 상태로 전환될 수 있습니다.

3. 동기화 기법 사용:
프로세스가 뮤텍스(mutexes), 세마포어(semaphores), 조건 변수(condition variables) 등의 동기화 기법을 사용하여 특정 조건이 충족될 때까지 대기하는 경우입니다.
이러한 동기화 메커니즘은 종종 다른 프로세스 또는 스레드와의 동기화를 위해 사용됩니다.


# 멀티 코어와 관련해서 
싱글 스레드 프로세서의 경우 하나의 코어에서 작동함 그렇기 때문에 만약 코어의 개수가 많고 프로세서의 개수가 적다면 우선순위와 관련된 영향이 적을 수 있다. 
멀티 스레드 프로세서는 스레드의 개수만큼 코어의 개수를 사용 





% 만약에 다운로드하는 프로그램이 있고 계속 돌아가는 프로그램이 있다면?
스케쥴링 정책 설정:
파일 다운로드 작업은 프로그램 자체에서는 서버에 자료를 요구하고 받는 기간동안은 cpu가 쉬는 시간이기 때문에 할 우선순위를 낮출 수 있다(SCHED_OTHER)
지속적인 처리 작업은 아마도 realtime 작업이나 민감한 작업일 가능성이 있기 때문에 (SCHED_FIFO 혹은 SCHED_RR)을 선택하는것이 좋다. 

SCHED_FIFO 와 SCHED_RR 의 차이는 둘다 우선순위를 보장하지만 SCHED_RR 에는 타임슬라이스 라는 것이 존재해서 우선순위가 같은 애들끼리 일정한 시간을 할당한다. 
그래서 A, B 의 두 작업이 존재하고 두개의 작업이 우선순위가 같다면 FIFO 의 경우는 A 가 들어가서 그 작업이 끝나거나 블록되기 전까지는 A 가 CPU를 점유하지만 RR의 경우는 미리 할당된 시간이 끝나면 작업이 끝마쳐지기 전에 B의 작업으로 넘어간다. 
