리눅스 실시간 스케줄링 시스템
리눅스에서 실시간 스케줄링은 특정 작업에 더 높은 우선순위를 부여하고, 보다 예측 가능한 실행을 보장하는 데 사용됩니다. 실시간 시스템의 주요 목적은 반응 시간을 최소화하고, 작업 처리 순서를 엄격하게 관리하는 것입니다.

1. 스케줄링 정책:

SCHED_FIFO: FIFO 실시간 정책입니다. 같은 우선순위를 가진 프로세스 간에는, 먼저 대기열에 들어온 프로세스가 먼저 실행됩니다.
SCHED_RR: Round-Robin 실시간 정책입니다. 이 정책은 동일한 우선순위를 가진 프로세스들에게 시간 할당량을 순환식으로 분배합니다.
SCHED_DEADLINE: 각 프로세스에게 실행 마감 시간을 부여합니다. 이 정책은 마감 시간이 가장 임박한 작업에게 우선순위를 부여합니다.



2. 우선순위 역전 방지:
우선순위 상속 (Priority Inheritance)
-우선순위 역전(Priority Inversion)은 낮은 우선순위의 프로세스가 높은 우선순위의 프로세스를 막는 상황을 말합니다. 우선순위 상속은 이를 방지하기 위해, 낮은 우선순위의 프로세스가 높은 우선순위의 프로세스를 차단할 경우, 낮은 우선순위 프로세스의 우선순위를 일시적으로 높여주는 기법입니다.



3. CPU 고정 (CPU Affinity)
- CPU 고정(CPU Affinity)는 특정 프로세스나 스레드가 특정 CPU 코어에서만 실행되도록 고정하는 기술입니다. 이는 운영 체제의 스케줄러가 프로세스나 스레드를 자유롭게 모든 CPU 코어에서 실행하지 않고, 지정된 코어에서만 실행하도록 제약을 가하는 것입니다.
    장점
        1. 캐시 효율성 향상 : 특정 프로세스나 스레드가 항상 동일한 CPU 코어에서 실행되도록 하면, 해당 코어의 CPU 캐시를 더 효율적으로 사용할 수 있습니다. 프로세스가 다른 코어로 이동하지 않기 때문에, 캐시 미스(cache miss)가 줄어들고 성능이 향상됩니다.
        2. 예측 가능한 성능 : 실시간 시스템에서 특정 작업이 항상 일정한 CPU 코어에서 실행되면, 작업의 지연 시간을 예측하기가 더 쉬워집니다. 이는 실시간 성능을 요구하는 애플리케이션에서 중요합니다.
        3. 경쟁 및 자원 경합 최소화 : 여러 스레드나 프로세스가 동시에 동일한 자원(예: 메모리, 캐시)을 사용해야 하는 경우, 이러한 스레드를 서로 다른 CPU 코어에 고정하면 자원 경합을 줄일 수 있습니다. 이는 성능을 안정적으로 유지하는 데 도움이 됩니다.
        4. 부하 분산 : 특정 CPU 코어에만 작업을 집중시킬 수 있기 때문에, CPU 부하를 더 효율적으로 분산시킬 수 있습니다. 예를 들어, CPU 코어 중 일부는 실시간 작업에 할당하고, 나머지는 비실시간 작업에 할당할 수 있습니다.

4. 락 회피 (Lock Avoidance) 및 비동기 프로그래밍

5. 실시간 타이머 (Real-Time Timers)(POSIX 실시간 타이머)
    특징 
        - 실시간 타이머는 밀리초(ms) 또는 마이크로초(µs) 단위의 고정밀 타이밍을 지원합니다. 이는 매우 정밀한 타이밍이 요구되는 작업, 예를 들어 "주기적인 센서 데이터 수집이나 제어 신호 생성" 등의 실시간 작업에서 유용합니다.
        - 주기적인 작업지원(반복 이벤트)
        - 유연한 타이머 설정 : 실시간 타이머를 특정방식에 따라도 사용이 가능함
        



6. 메모리관리(Memory Management)-> memory Locking (메모리잠금-> 실시간 프로세스가 실행되는 동안 메모리 페이징이 발생하지 않도록 하기 위해)


